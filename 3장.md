* IoC와 DI의 주 목적 : 컴포넌트의 의존성을 제공하고 이러한 의존성을 라이프사이클 전반에 걸쳐 관라하는 것보다 간편한 메커니즘을 제공하는 것.

* IoC 두 가지 하위분류로 나눌 수 있음
  * 의존성 주입(DI)
  * 의존성 룩업(DL)
    * 이들은 다시 구체적인 IoC 구현제로 나늼.

* IoC 종류
  * 의존성 주입(DI) : 이 방식의 IoC에서는 IoC 컨테이너가 컴포넌트에 의존성을 주입합니다.
    * 생성자(constructor) 의존성 주입
    * 수정자(setter) 의존성 주입
  * 의존성 룩업(DL) : 이 방식의 IoC에서는 컴포넌트 스스로 의존성의 참조를 가져와야 합니다.
     * 의존성 풀(Dependency Pull)
     * 의존성 룩업(CDL)
     
* 3.2.1 의존성 풀
  * 의존성 풀에서는 필요에 따라 레지스트리에서 의존성을 가져오게 됩니다.
    ex) JNDI API를 사용한 EJB 컴포넌트 룩업
        * JNDI(Java Naming and Directory Interface)는 
          * 디렉터리 서비스에서 제공하는 데이터 및 객체를 발견(discover)하고 참고(lookup)하기 위한 자바 API
          * 서버에서 관리하고 있는 리소스에 대한 정보를 알고 있고 특정 리소스를 찾아서 사용할 수있도록 객체를 반환
          
        ```java
         // 추억의 lookup 소스..

         public class DatabaseManager
         {
            public static Connection getConnection() throws Exception
            {
               Context ctx = new InitialContext();
               DataSource ds = (DataSource) ctx.lookup("java:comp/env/jdbc/myoracle");
               return ds.getConnection();
            }
         }
         ```

  * 스프링 프레임워크도 자신이 관리하는 컴포넌트를 가져오는 메커니증 중 하나로서 의존성 풀을 제공
  * 의존성 풀 사용 예
 
```java

package com.apress.prospring5.ch3;

import com.apress.prospring5.ch2.decoupled.MessageRenderer;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class DependencyPull {
    public static void main(String... args) {
        ApplicationContext ctx = new ClassPathXmlApplicationContext
           ("spring/app-context.xml");

        MessageRenderer mr = ctx.getBean("renderer", MessageRenderer.class);
        mr.render();
    }
}
```


* 3.2.2 문맥에 따른 의존성 룩업(CDL)
  * 의존성 풀처럼 특정 중앙 레지스트리에서 의존성을 가져오는 것이 아니라 **자원을 관리하는 컨테이너**에서 의존성을 가져옴
  * 늘 수행되는 것이 아니라 몇 사기 정해진 시점에 수행
  * 다음은 문맥에 따른 의존성 룩업 메커니즘
    * 의존 객체 -> 룩업 -> 컨테이너 
  *  컨테이너에서 의존성을 가져오는 컴포넌트
  
```java
public class ContextualizedDependencyLookup implements ManagedComponent {

    private Dependency dependency;

    // 1)의존성 룩업을 수행하는 메소드
    
    @Override
    public void performLookup(Container container) {
        this.dependency = (Dependency) container.getDependency("myDependency");
    }

    @Override
    public String toString() {
        return dependency.toString();
    }
}
```

3.2.3 생성자 의존성 주입
* 컴포넌트의 생성자(또는 여러 생성자)를 이용해서 해당 컴포넌트가 필요로하는 의존성을 제공하는 방식.
* 어떤 컴포넌트가 의존성을 인수로 가져오도록 생성자 또는 여러 생성자를 선언한다면 IoC 컨테이너는 해당 컴포넌트를 초기화할 때 컴포넌트에 필요한 의존성을 전달함.
* 주의점 : 생성자 주입을 사용할 때 의존성 주입 없이는 빈을 생성할 수 없으므로 **반드시 의존성을 주입**해야함!
* 생성자 의존성 주입 예제 코드

```java
public class ConstructorInjection {
	private Dependency dependency;

	public ConstructorInjection(Dependency dependency) {
		this.dependency = dependency;
	}

	@Override
	public String toString() {
		return dependency.toString();
	}
}
```

3.2.4 수정자 의존성 주입
 * 수정자(setter) 의존성 주입 방식에서 IoC 컨테이너는 자바빈 방식의 **수정자 메서드**를 이용해 컴포넌트의 의존성을 주입.
 * 컴포넌트의 수정자는 **IoC 컨테이너가 관리할 수 있도록 의존성을 노출**함.
 * 수정자 주입을 사용할 때 명확한 것은 의존성 없이도 객체를 생성할 수 있으며 해당 수정자를 호출해 의존성을 나중에 제공할 수 있음.
 * 의존성 주입이 필요한 일반적인 컴포넌트 예제

```java
public class SetterInjection {

	private Dependency dependency;

	public void setDependency(Dependency dependency) {
		this.dependency = dependency;
	}

	@Override
	public String toString() {
		return dependency.toString();
	}
}
```

3.2.5 **의존성 주입** vs. 의존성 룩업
* 현재 사용하는 컨테이너에 따라 IoC의 방식이 정해짐
* ex) EJB 2.1 이하 버전을 사용할 때 EJB를 JEE 컨테이너에서 가져오려면 의존성 룩업(JNDI를 통한) 방식의 IoC를 사용해야 함.
      스프링에서는 초기 빈 룩업을 제외하면 컴포넌트와 의존성은 항상 의존성 주입 방식의 IoC를 이용해 연결됨.
* 주입 방식을 선택하는 가장 큰 이유는 의존성 주입을 사용하면 그만큼 개발이 쉬워지기 때문. 작성해야 하는 코드량 줄이고 코드도 간결. IDE를 이용해 자동화도 가능.
* 주입 코드는 **객체가 필드에만 저장**됨. 저장소나 컨테이너에서 의존성을 가져오는 코드가 전혀 필요하지 않음. 따라서 코드는 훨씬 단순해지고 에러도 줄어듬.

3.2.6 수정자 주입 vs. 생성자 주입
* 생성자 주입
  * 컴포넌트 사용 전에 해당 컴포넌트의 의존성을 반드시 갖고 있어야 할 때 매우 유용. 의존성 점검 메커니즘을 제공하는지와 상관없이 의존성에 대한 요구사항 지정 가능.
  * 빈 객체를 불변 객체로 사용 가능.
* 수정자 주입
  * 기존 의존성을 제공할 때 일반적으로 **수정자 주입이 의존성 주입에 가장 좋은 방법**
  * 인터페이스에서 모든 의존성을 선언할 수 있음
  
* 의존성 주입 메소드를 비즈니스 인터페이스에서 정의하지 않고, 비즈니스 인터페이스를 구현하는 클래스에서 이 메소드를 정의!

```java
public interface Oracle {
    String defineMeaningOfLife();
}
```

```java
public class BookwormOracle implements Oracle {
    private Encyclopedia encyclopedia;

    public void setEncyclopedia(Encyclopedia encyclopedia) {
        this.encyclopedia = encyclopedia;
    }

    @Override
    public String defineMeaningOfLife() {
        return "Encyclopedias are a waste of money -  go see the world instead";
    }
}
```

* BookwormOracle 클래스는 Oracle 인터페이스를 구현했을 뿐만 아니라 의존성 주입을 위한 수정자도 정의
* 스프링은 이와 같은 구조를 다루는데 훨씬 더 편리
* 여기서 비즈니스 인터페이스에서 의존성을 정의할 필요없음
* 의존성을 정의하는 인터페이스를 사용할 수 있다는 것이 수정자 주입의 잘 알려진 장점!
  * 하지만 실제로는 주입을 위한 수정자가 사용자 인터페이스의 외부에 존재하도록 노력해야함
  
**3.3 스프링 제어 역전**
* 제어 역정(Inversion of Control, IoC)은 스프링이 하는 일 중에 가장 큰 부분을 차지!
* 의존성 룩업 기능이 제공되지만, **스프링 구현의 핵심은 의존성 주입**임!
  * 스프링의 의존성 주입 메커니증
    [의존 객체] <------의존성 주입------- [스프링 BeanFactory 컨테이너]

3.4 빈과 빈 팩터리
스프링의 의존성 주입 컨테이너의 핵심은 **빈 백터리 인터페이스** 입니다.
* 빈 팩터리
  * 컴포넌트 관리
  * 컴포넌트의 라이프사이클뿐만 아니라 의존성까지 관리
* 빈 팩터리 
