* IoC와 DI의 주 목적 : 컴포넌트의 의존성을 제공하고 이러한 의존성을 라이프사이클 전반에 걸쳐 관라하는 것보다 간편한 메커니즘을 제공하는 것.

* IoC 두 가지 하위분류로 나눌 수 있음
  * 의존성 주입(DI)
  * 의존성 룩업(DL)
    * 이들은 다시 구체적인 IoC 구현제로 나늼.

* IoC 종류
  * 의존성 주입(DI) : 이 방식의 IoC에서는 IoC 컨테이너가 컴포넌트에 의존성을 주입합니다.
    * 생성자(constructor) 의존성 주입
    * 수정자(setter) 의존성 주입
  * 의존성 룩업(DL) : 이 방식의 IoC에서는 컴포넌트 스스로 의존성의 참조를 가져와야 합니다.
     * 의존성 풀(Dependency Pull)
     * 의존성 룩업(CDL)
     
* 3.2.1 의존성 풀
  * 의존성 풀에서는 필요에 따라 레지스트리에서 의존성을 가져오게 됩니다.
    ex) JNDI API를 사용한 EJB 컴포넌트 룩업
        * JNDI(Java Naming and Directory Interface)는 
          * 디렉터리 서비스에서 제공하는 데이터 및 객체를 발견(discover)하고 참고(lookup)하기 위한 자바 API
          * 서버에서 관리하고 있는 리소스에 대한 정보를 알고 있고 특정 리소스를 찾아서 사용할 수있도록 객체를 반환
          
        ```java
         // 추억의 lookup 소스..

         public class DatabaseManager
         {
            public static Connection getConnection() throws Exception
            {
               Context ctx = new InitialContext();
               DataSource ds = (DataSource) ctx.lookup("java:comp/env/jdbc/myoracle");
               return ds.getConnection();
            }
         }
         ```

  * 스프링 프레임워크도 자신이 관리하는 컴포넌트를 가져오는 메커니증 중 하나로서 의존성 풀을 제공
  * 의존성 풀 사용 예
 
```java

package com.apress.prospring5.ch3;

import com.apress.prospring5.ch2.decoupled.MessageRenderer;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class DependencyPull {
    public static void main(String... args) {
        ApplicationContext ctx = new ClassPathXmlApplicationContext
           ("spring/app-context.xml");

        MessageRenderer mr = ctx.getBean("renderer", MessageRenderer.class);
        mr.render();
    }
}
```


* 3.2.2 문맥에 따른 의존성 룩업(CDL)
  * 의존성 풀처럼 특정 중앙 레지스트리에서 의존성을 가져오는 것이 아니라 **자원을 관리하는 컨테이너**에서 의존성을 가져옴
  * 늘 수행되는 것이 아니라 몇 사기 정해진 시점에 수행
  * 다음은 문맥에 따른 의존성 룩업 메커니즘
    * 의존 객체 -> 룩업 -> 컨테이너 
  *  컨테이너에서 의존성을 가져오는 컴포넌트
  
```java
public class ContextualizedDependencyLookup implements ManagedComponent {

    private Dependency dependency;

    // 1)의존성 룩업을 수행하는 메소드
    
    @Override
    public void performLookup(Container container) {
        this.dependency = (Dependency) container.getDependency("myDependency");
    }

    @Override
    public String toString() {
        return dependency.toString();
    }
}
```

3.2.3 생성자 의존성 주입
* 컴포넌트의 생성자(또는 여러 생성자)를 이용해서 해당 컴포넌트가 필요로하는 의존성을 제공하는 방식.
* 어떤 컴포넌트가 의존성을 인수로 가져오도록 생성자 또는 여러 생성자를 선언한다면 IoC 컨테이너는 해당 컴포넌트를 초기화할 때 컴포넌트에 필요한 의존성을 전달함.
* 주의점 : 생성자 주입을 사용할 때 의존성 주입 없이는 빈을 생성할 수 없으므로 **반드시 의존성을 주입**해야함!
* 생성자 의존성 주입 예제 코드

```java
public class ConstructorInjection {
	private Dependency dependency;

	public ConstructorInjection(Dependency dependency) {
		this.dependency = dependency;
	}

	@Override
	public String toString() {
		return dependency.toString();
	}
}
```

3.2.4 수정자 의존성 주입
 * 수정자(setter) 의존성 주입 방식에서 IoC 컨테이너는 자바빈 방식의 **수정자 메서드**를 이용해 컴포넌트의 의존성을 주입.
 * 컴포넌트의 수정자는 **IoC 컨테이너가 관리할 수 있도록 의존성을 노출**함.
 * 수정자 주입을 사용할 때 명확한 것은 의존성 없이도 객체를 생성할 수 있으며 해당 수정자를 호출해 의존성을 나중에 제공할 수 있음.
 * 의존성 주입이 필요한 일반적인 컴포넌트 예제

```java
public class SetterInjection {

	private Dependency dependency;

	public void setDependency(Dependency dependency) {
		this.dependency = dependency;
	}

	@Override
	public String toString() {
		return dependency.toString();
	}
}
```

3.2.5 **의존성 주입** vs. 의존성 룩업
* 현재 사용하는 컨테이너에 따라 IoC의 방식이 정해짐
* ex) EJB 2.1 이하 버전을 사용할 때 EJB를 JEE 컨테이너에서 가져오려면 의존성 룩업(JNDI를 통한) 방식의 IoC를 사용해야 함.
      스프링에서는 초기 빈 룩업을 제외하면 컴포넌트와 의존성은 항상 의존성 주입 방식의 IoC를 이용해 연결됨.
* 주입 방식을 선택하는 가장 큰 이유는 의존성 주입을 사용하면 그만큼 개발이 쉬워지기 때문. 작성해야 하는 코드량 줄이고 코드도 간결. IDE를 이용해 자동화도 가능.
* 주입 코드는 **객체가 필드에만 저장**됨. 저장소나 컨테이너에서 의존성을 가져오는 코드가 전혀 필요하지 않음. 따라서 코드는 훨씬 단순해지고 에러도 줄어듬.

3.2.6 수정자 주입 vs. 생성자 주입
* 생성자 주입
  * 컴포넌트 사용 전에 해당 컴포넌트의 의존성을 반드시 갖고 있어야 할 때 매우 유용. 의존성 점검 메커니즘을 제공하는지와 상관없이 의존성에 대한 요구사항 지정 가능.
  * 빈 객체를 불변 객체로 사용 가능.
* 수정자 주입
  * 기존 의존성을 제공할 때 일반적으로 **수정자 주입이 의존성 주입에 가장 좋은 방법**
  * 인터페이스에서 모든 의존성을 선언할 수 있음
  
* 의존성 주입 메소드를 비즈니스 인터페이스에서 정의하지 않고, 비즈니스 인터페이스를 구현하는 클래스에서 이 메소드를 정의!

```java
public interface Oracle {
    String defineMeaningOfLife();
}
```

```java
public class BookwormOracle implements Oracle {
    private Encyclopedia encyclopedia;

    public void setEncyclopedia(Encyclopedia encyclopedia) {
        this.encyclopedia = encyclopedia;
    }

    @Override
    public String defineMeaningOfLife() {
        return "Encyclopedias are a waste of money -  go see the world instead";
    }
}
```

* BookwormOracle 클래스는 Oracle 인터페이스를 구현했을 뿐만 아니라 의존성 주입을 위한 수정자도 정의
* 스프링은 이와 같은 구조를 다루는데 훨씬 더 편리
* 여기서 비즈니스 인터페이스에서 의존성을 정의할 필요없음
* 의존성을 정의하는 인터페이스를 사용할 수 있다는 것이 수정자 주입의 잘 알려진 장점!
  * 하지만 실제로는 주입을 위한 수정자가 사용자 인터페이스의 외부에 존재하도록 노력해야함
  
**3.3 스프링 제어 역전**
* 제어 역정(Inversion of Control, IoC)은 스프링이 하는 일 중에 가장 큰 부분을 차지!
* 의존성 룩업 기능이 제공되지만, **스프링 구현의 핵심은 의존성 주입**임!
  * 스프링의 의존성 주입 메커니증
    [의존 객체] <------의존성 주입------- [스프링 BeanFactory 컨테이너]

3.4 빈(Bean)과 빈 팩터리(Bean Factory)
스프링의 의존성 주입 컨테이너의 핵심은 **빈 백터리 인터페이스** 입니다.
* 빈 팩터리
  * 컴포넌트 관리
  * 컴포넌트의 라이프사이클뿐만 아니라 의존성까지 관리

3.4.2 BeanFactory 구현체
* 독립 실행형 자바 어플리케이션에서 원하는 처리를 하기 위해 스프링의 BeanFactory를 초기화하고 oracle 빈을 가져오는 방법 코드

```java
public class XmlConfigWithBeanFactory {

	public static void main(String... args) {
	        // BeanFactory 구현체 중 하나인 DefaultListableBeanFactory 사용
		DefaultListableBeanFactory factory = new DefaultListableBeanFactory();
		
		// XmlBeanDefinitionReader를 사용해 XML 파일의 BeanDefinition 정보 읽음
		XmlBeanDefinitionReader rdr = new XmlBeanDefinitionReader(factory);
		
		rdr.loadBeanDefinitions(new ClassPathResource("spring/xml-bean-factory-config.xml"));
		
		// oracle 빈을 가져오기
		Oracle oracle = (Oracle) factory.getBean("oracle");
		
		System.out.println(oracle.defineMeaningOfLife());
	}
}
```

* xml-bean-factory-config.xml

```xml
<?xml version="1.0" encoding="UTF-8"?>
    
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://www.springframework.org/schema/beans 
        http://www.springframework.org/schema/beans/spring-beans.xsd">

    <bean id="oracle" name="wiseworm" class="com.apress.prospring5.ch3.BookwormOracle"/>
</beans>
```

3.4.3 애플리케이션 컨텍스트(ApplicationContext)
* 스프링의 애플리케이션 컨텍스트 인터페이스는 **BeanFactory를 상속한 인터페이스**
* DI 서비스 외에도 트랜잭션 서비스, AOP 서비스, 국제화(il8n)를 위한 메시지 소스, 애플리케이션 이벤트 처리와 같은 여러 서비스 제공
* 스프링 기반 애플리케이션 개발 할 때 **ApplicationContext 인터페이스**를 이용해 스프링을 사용하는 것을 권장

* 스프링은 ApplicationContext를 
  * **직접 코드**로 **부트스트랩**(직접 인스턴스를 생성하고 적절한 애플리케이션 구성을 불러오는 방식)하거나
  * 웹 컨테이너 환경에서 **ContextLoaderListener를 이용**해 부트스트랩 합니다.
  

3.5.1 스프링 구성 옵션 설정하기
* 스프링에서 애플리케이션 구성을 정의할 수 있는 옵션
  * 빈 정의 : 프로퍼티 or XML 파일을 사용해 빈 정의할 수 있도록 지원
  * JDK 5가 출시되고, 스프링이 자바 애너테이션 지원하면서 스프링 2.5부터는 ApplicationContext를 구성하는데 자바 애너테이션을 지원하기 시작!
  * XML과 애너테이션 방식 중 어느것이 더 나을까 -> 각 장단점이 있기에 정답 없음.
    * XML 파일을 사용하면 모든 구성을 자바에서 분리해 외부에서 관리
    * 애너테이션을 사용하면 개발자가 코드 내에서 DI 구성을 정의하고 확인 가능
  * 일반적인 접근 중 하나는
    * XML 파일에 애플리케이션의 인프라(예를 들어 데이터 소스, 트랜잭션 관리자, JMS 연결 팩터리(Connection Factory), JMX 등) 정의하고
    * 애너테이션으로 DI 구성(주임 가능 빈과 빈의 의존성)을 정의하는 방식
  => 어떤 옵션을 선택하는지, 선택한 방법을 일관성 있게 준수하고 전체 개발팀이 분명히 이해할 수 있게 메시지를 명확히 전달
  
  
3.5.2 기본 구성의 개요
* XML 구성을 사용하려면 애플리케이션에서 필요한 **스프링 네임스페이스 베이스**를 선언해야함


* 스프링 빈 정의에 사용하는 네임스페이스 선언의 예 (app-context-xml.xml)

```xml
<?xml version="1.0" encoding="UTF-8"?>

<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:p="http://www.springframework.org/schema/p"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
          http://www.springframework.org/schema/beans/spring-beans.xsd">

    <bean id="renderer"
        class="com.apress.prospring5.ch2.decoupled.StandardOutMessageRenderer"
        p:messageProvider-ref="provider"/>

    <bean id="provider"
        class="com.apress.prospring5.ch2.decoupled.HelloWorldMessageProvider"/>
</beans>
```

* **컴포넌트 스캐닝 설정**을 한 XML 구성 파일 (app-context-annotation.xml)

```xml
<?xml version="1.0" encoding="UTF-8"?>

<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:context="http://www.springframework.org/schema/context"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
          http://www.springframework.org/schema/beans/spring-beans.xsd
          http://www.springframework.org/schema/context 
          http://www.springframework.org/schema/context/spring-context.xsd">

    <context:component-scan 
          base-package="com.apress.prospring5.ch3.annotated"/>
</beans>
```

* <context:component-scan> 태그는 
  * 지정한 패키지의 모든 하위 패키지에 있는 클래스에 선언된 @Autowired, @Inject, @Resource 애너테이션 뿐만 아니라
  * @Component, @Controller, @Repository, @Service 애너테이션이 선언된, 의존성 주입이 가능한 빈의 코드를 스캔하도록 스프링에게 지시함!!
  * 여러 패키지 정의 가능 : <context:component-scan> 태그에서 쉼표, 세미콜론, 공백을 구분 기호로 사용해 여러 패키지를 정의할 수 있음
  * 스캔 범위 제어 가능 : 이 태그에서는 컴포넌트 스캔의 범위와 제외 범위를 지정해 스캔 범위 제어 가능

  
  * 스캔에서 제외할 대상(클래스 또는 인터페이스) 예

```xml
<?xml version="1.0" encoding="UTF-8"?>

<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:context="http://www.springframework.org/schema/context"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
          http://www.springframework.org/schema/beans/spring-beans.xsd
          http://www.springframework.org/schema/context 
          http://www.springframework.org/schema/context/spring-context.xsd">

    <context:component-scan 
		base-package="com.apress.prospring5.ch3.annotated"/>
	  <context:exclude-filter type="assignable" expression="com.example.NotAService"/>
    </context:component-scan>

</beans>
```


3.5.3 스프링 컴포넌트 선언하기
* 스프링에게 이 빈(개발한 클래스)이 다른 빈에 주입될 수 있다는 것을 알려주고, 스프링이 이 빈들을 관리하게 해야 함.

1) xml 설정 
* MessageRenderer가 렌더링할 메시지를 제공하는 MessageProvider에 의존

```java
public interface MessageRenderer {
	void render();
	void setMessageProvider(MessageProvider provider);
	MessageProvider getMessageProvider();
}

// renderered 구현체
public class StandardOutMessageRenderer implements MessageRenderer {

    private MessageProvider messageProvider = null;

    public void render() {
        if (messageProvider == null) {
            throw new RuntimeException(
                    "You must set the property messageProvider of class:"
                            + StandardOutMessageRenderer.class.getName());
        }

        System.out.println(messageProvider.getMessage());
    }

    public void setMessageProvider(MessageProvider provider) {
        this.messageProvider = provider;
    }

    public MessageProvider getMessageProvider() {
        return this.messageProvider;
    }

}

// provider 인터페이스
public interface MessageProvider {
    String getMessage();
}


// provider 구현체
public class HelloWorldMessageProvider implements MessageProvider {

@Override
    public String getMessage() {
        return "Hello World!";
    }
}
```


app-context-xml.xml

```xml
<?xml version="1.0" encoding="UTF-8"?>

<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:p="http://www.springframework.org/schema/p"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
          http://www.springframework.org/schema/beans/spring-beans.xsd">

    <bean id="renderer"
        class="com.apress.prospring5.ch2.decoupled.StandardOutMessageRenderer"
        p:messageProvider-ref="provider"/>

    <bean id="provider"
        class="com.apress.prospring5.ch2.decoupled.HelloWorldMessageProvider"/>
</beans>
```


2) 애너테이션 설정 예
* 애너테이션을 사용해 빈 정의를 생성하는 클레스 예

```java
//간단한 빈
@Service("provider")
public class HelloWorldMessageProvider implements MessageProvider {

    @Override
    public String getMessage() {
        return "Hello World!";
    }
}
```


```java
//복잡한 서비스 빈
@Service("renderer")
public class StandardOutMessageRenderer implements MessageRenderer {

    private MessageProvider messageProvider = null;

    public void render() {
        if (messageProvider == null) {
            throw new RuntimeException(
                    "You must set the property messageProvider of class:"
                            + StandardOutMessageRenderer.class.getName());
        }

        System.out.println(messageProvider.getMessage());
    }

    public void setMessageProvider(MessageProvider provider) {
        this.messageProvider = provider;
    }

    public MessageProvider getMessageProvider() {
        return this.messageProvider;
    }

}
```

* **ApplicationContext로부터 빈을 얻는 방법**

```java
public class DeclareSpringComponents {

	public static void main(String... args) {
		GenericXmlApplicationContext ctx = new GenericXmlApplicationContext();
		ctx.load("classpath:spring/app-context-xml.xml");
		ctx.refresh();
		MessageRenderer messageRenderer = ctx.getBean("renderer",
				MessageRenderer.class);
		messageRenderer.render();
		ctx.close();
	}
}
```


3.5.3.1 자바 구성(Java Configuration) 사용하기
* 생성된 빈 타입을 드러내도록 클래스를 수정하지 않아도 app-context-xml.xml을 구성 클래스로 교체 가능.
* 이는 애플리케이션에게 필요한 빈 타입이 수정할 수 없는 서드파티 라이브러리의 일부인 경우에 유용
  * 이러한 구성 클래스에는 **@Configuration 애너테이션**을 적용!!
  * 구성 클래스 내에서는 스프링 IoC 컨테이너가 빈 인스턴스를 만들 때 직접 호출하는 @Bean 애너테이션이 적용된 메서드가 포함돼 있음 

* 생성되는 빈의 이름이 되는 메서드 이름을 표시하는 예. provider 메소드.
```java
@Configuration
public class HelloWorldConfiguration {

	@Bean
	public MessageProvider provider() {
		return new HelloWorldMessageProvider();
	}

	@Bean
	public MessageRenderer renderer(){
		MessageRenderer renderer = new StandardOutMessageRenderer();
		renderer.setMessageProvider(provider());
		return renderer;
	}
}
```

* **AnnotationConfigApplicationContext**를 사용해 빈 가져오기 (ApplicationContext 구현체 사용)

```java
public class HelloWorldSpringAnnotated {
    public static void main(String[] args) {
       ApplicationContext ctx = new AnnotationConfigApplicationContext(HelloWorldConfiguration.class)
       MessageRenderer messageRenderer = ctx.getBean("renderer", MessageRenderer.class);
       messageRenderer.render()
    }
}
```

* DefaultListableBeanFactory 대신 AnnotationConfigApplicationContext 인스턴스를 생성함
* AnnotationConfigApplicationContext 클래스는 ApplicationContext 인터페이스를 구현한 클래스로, 
* HelloWorldConfiguration클래스에 정의된 구성을 이용해 스프링의 ApplicationContext를 부트스트랩 할 수 있음
* 빈 정의 구성이 해당 빈 클래스의 일부이므로 구성 클래스가 더 이상 @Bean 애너테이션이 적용된 매소드를 갖고 있지 않아도 됨
* <context:component-scanning ... />과 동일한 역할을 하는 애너테이션을 구성 클래스에 추가하여 컴포넌트 스캐닝을 할 수 있음


3.5.3.2 **수정자 주입 사용**하기
* XML을 이용해 수정자 주입을 구성하려면 <bean> 태그 아래에 의존성을 주입할 <property> 태그를 지정

```xml
<beans>
    <bean id="renderer" class="com.apress.prospring5.ch2.decoupled.StandardOutMessageRenderer">
    <property name="messageProvider ref="provider" />
</beans>
```


* 이 코드에서 provider 빈이 messageProvider 프로퍼티에 지정되어 있음을 알 수 있음
* ref 애트리뷰트를 사용하여 프로퍼티에 빈 참조를 지정할 수 있음
* 스프링 2.5버전 이상을 사용한다면 XML 구성 파일에 p네임 스페이스를 선언하여 의존성 주입을 할 수 있음
* 네임스페이스는 XSD 파일에 정의되어 있지 않고 스프링 코어에만 존재함

```xml
<beans>
    <bean id="renderer" class="com.apress.prospring5.ch2.decoupled.StandardOutMessageRenderer" p:messageProvider-ref="provider" />
</beans>
```

* 애너테이션을 사용한다면 수정자 메서드에 @Autowired 애너테이션만 추가하여 간단하게 사용할 수 있음

```xml
@Service("renderer")
public class StandardOutMessageRenderer implements MessgeRenderer [
    @Override
    @Autowired
    public void setMessageProvider(MessageProvider provider) {
        this.MessageProvider = provider;
    }
}
```


* @Autowired 대신 @Resource(name="messageProvider")를 사용해도 같은 결과를 얻을 수 있음
* @Resource는 @Autowired와 달리 더 세부적인 DI요구에 대응하려는 목적으로 name인자를 제공
* XML 구성 파일에서 <context:component-scan /> 태그를 선언했으므로 스프링은 ApplicationContext를 초기화하는 동안에 @Autowired를 발견하고 필요에 따라 의존성을 주입


3.5.3.3 **생성자 주입 사용**하기
* 이제까지는 HelloWorldMessageProvider의 getMessage()를 호출하면 하드코딩된 메시지를 동일하게 반영했음
* 메시지 값을 전달하지 않고서 ConfigurableMessageProvider의 인스턴스를 생성할 수 없기 때문에 이 클래스는 생성자 주입을 하는게 좋음
* 아래의 코드는 ConfigurableMessageProvider 인스턴스를 생성하려는 목적으로 provider 빈을 다시 정의하고 생성자 주입으로 메시지를 주입하는 방법을 보여줌

```xml
<bean id="messageProvider" class="com.apress.prospring5.ch3.xml.ConfigurableMessageProvider">
    <constructor-arg value="Hi~~~! This is message~~~!" />
</bean>
```

* <property> 태그 대신 <constructor-arg> 사용
* 다른 빈을 전달하지 않고 문자열만을 전달하기 때문에 ref대신 value 애트리뷰트를 사용하여 생성자 인수의 값을 지정
* 둘 이상의 생성자 인수가 있거나 클래스에 둘 이상의 생성자가 있는 경우에는 인수 인덱스를 지정하는 index애트리뷰트를 각 <constructor-arg>태그에 제공해야 함
* 인자 사이의 혼동을 피하고 스피링이 올바른 생성자를 선택하도록 하려면 다중 인수를 갖는 생성자를 다룰 때마가 항상 index애트리뷰트를 사용하는 것이 좋음
* <constructor-arg>태그는 c네임 스페이스를 사용하여 표현할 수도 있음

```xml
<bean id="messageProvider" class="com.apress.prospring5.ch3.xml.ConfigurableMessageProvider"
    c:message="Hi~~~! This is message~~~!" />
</bean>
```

* 애너테이션을 이용해 생성자 주입을 할 때에도 마찬가지로 대상 빈의 생성자 매소드에 @Autowired 애너테이션을 사용
* 이 방식은 수정자 주입 방식을 대체할 수 있음

```java
@Service("provider")
public class ConfigurableMessageProvider implements MessageProvider {

    private String message;

    @Autowired
    public ConfigurableMessageProvider(@Value("Configurable message) String message) {
        this.message = message;
    }

    @Override
    public String getMessage() {
        return this.message;
    }
}
```

* @Value를 사용하여 생성자에 주입할 값을 정의함
* 이런 방식으로 스프링에서는 빈에 값을 주입함
* 간단한 문자열 외에 동적으로 값을 주입하고 싶다면 강력한 기능인 SpEL을 사용할 수 있음
* 그러나 예제와 같이 코드에 값을 하드코딩하는 것은 좋지 않음
* 애너테이션 방식의 DI를 사용하더라도 주입할 값은 외부에 두는 것이 좋음
* 메시지를 외부화 하기 위해서는 아래와 같이 애너테이션 구성파일에서 메시지를 스프링 빈으로 정의해야 함

```xml
<beans .... />
    <context:component-scan base-package="com.apress.prospring5.ch3.annotated" />
    <bean id="message" class="java.lang.String" c:_0="This is message" />
</beans>
```

* Id가 message이고 클래스타입이 java.lang.String인 빈을 정의
* 생성자 주입을 위해 c네임스페이스를 사용해 문자열 값을 설정
* _0는 생성자 인수에 대한 인덱스를 나타냄
* 이 빈을 사용하면 아래와 같이 @Value를 제거해도 됨

```java
@Service("provider")
public class ConfigurableMessageProvider implements MessageProvider {
    
    private String message;

    @Autowired
    public ConfigurableMessageProvider(String message) {
        this.message = message;
    }

    @Override
    public String getMessage() {
        return this.message;
    }
}
```

* message 빈의 ID가 ConfigurableMessageProvider 클래스의 생성자에 지정된 인자의 이름과 동일하게 선언되었기 때문에 스프링은 @Autowired 애너테이션을 감지하여 값을 생성자 메소드에 주입할 것임
* 인수의 개수도 같은 생성자가 있는 경우 스프링이 어떤 생성자를 사용하여 주입을 해야할 지 판단하지 못할 수도 있음

<bean id="messageProvider" class="com.apress.prospring5.ch3.xml.ConfigurableMessageProvider" >
    <constructor-arg type="int">
        <value>90</value>
    </constructor-arg>
</bean>

* <constructor-arg> 태그에는 스프링이 찾아야 할 인수의 데이터 타입을 지정하는 type 애트리뷰트가 있음
* 애너테이션 방식의 생성자 주입을 사용할 때에는 애너테이션을 대신 생성자 메소드에 직접 적용해 이런 혼란을 피할 수 있음

```java
@Service("ConstructorConfusion")
public class ConstructorConfusion {

    private String someValue;

    public ConstructorConfusion(String message) {
        this.message = message;
    }


    @Autowired
    public ConstructorConfusion(@Value("90") int message) {
        this.message = message;
    }
        ...
}
```

* 원하는 생성자 매소드에 @Autowired 애너테이션을 적용하면 스프링은 이 메소드를 사용해 빈 인스턴스를 생성하고 지정한 값을 주입함
* @Autowired 애너테이션은 생성자 메소드 중에서 하나에만 적용할 수 있음
* 하나 이상의 생성자에 적용하면 스프링은 ApplicationContext를 부트스트랩하는 과정에서 오류를 일으킴

3.5.3.4 **필드 주입 사용**하기

* 의존성을 생성자나 수정자를 사용하지 않고 필드에 직접 주입함
* 클래스 멤버 변수에 @Autowired 애너테이션을 적용
* 의존성이 필요한 객체의 내부에서만 주입된 의존성을 사용할 경우 사용 하면 개발자가 빈 초기 생성 시 의존성 주입에 사용되는 코드를 작성하지 않아도 되므로 실용적임

```java
@Service("singer")
public class singer {

    @Autowired
    private Inspiration inspirationBean;

    public void sing() {
        System.out.println("....." + inspirationBean.lyric())
    }
}
```

* Inspiration 필드가 private이지만 스프링 IoC 컨테이너가 의존성을 주입하는 것에는 문제없음
* 스프링 컨테이너가 리플렉션을 이용해 필요한 의존성을 주입하기 때문
* 아래 코드는 스프링 IoC컨테이너가 생성할 빈의 정의를 찾을 수 있도록 컴포넌트 스캔 설정을 활성화하는 구성

```xml
<beans .... />
    <context:component-scan base-package="com.apress.prospring5.ch3.annotated" />
</beans>
```

* 스프링 IoC 컨테이너는 Inspiration타입의 빈을 발견하면 singer 빈의 inspirationBean 멤버에 해당 빈을 주입할 것
* 필드 주입의 단점

* 의존성을 추가하기 쉽지만 단일 책임 원칙을 위반하지 않도록 주의해야함
  * 더 많은 의존성이 생기면 클래스에 대한 책임이 커지므로 리팩토링 시에 관심사를 분리하기 어려움
  * 클래스가 비대해지는 상황은 생성자나 수정자 주입을 사용하면 쉽게 알 수 있지만 필드 주입은 알아채기 어려움
* 의존성 주입의 책임은 스프링 컨테이너에게 있지만, 클래스는 public 인터페이스의 매소드나 생성자를 이용해 필요한 의존성 타입을 명확하게 전달해야함
  * 그러나 필드 주입을 사용하면 어떤 타입의 의존성이 실제 필요한지, 의존성이 필수인지 여부가 명확하지 않을 수도 있음
* 필드 주입은 final 필드에 사용할 수 없음. 이 타입 필드는 오직 생성자 주입만을 사용하여 초기화 할 수 있음
* 필드 주입은 의존성을 수동으로 주입해야하므로 테스트 코드를 작성하기 어려움


3.5.3.5 **주입 인자 사용**하기

* 스프링은 다른 컴포넌트나 단순 값 외에 자바 컬렉션, 외부에 정의된 프로퍼티, 다른 팩터의 빈을 주입할 수 있도록 많은 옵션의 주입인자를 지원함
* 수정자 주입이나 생성자 주입 시에 <property>, <constructor-arg> 태그의 관련 태그들을 사용해 다양한 타입의 주입 인자를 사용할 수 있음














	
