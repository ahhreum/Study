* IoC와 DI의 주 목적 : 컴포넌트의 의존성을 제공하고 이러한 의존성을 라이프사이클 전반에 걸쳐 관라하는 것보다 간편한 메커니즘을 제공하는 것.

* IoC 두 가지 하위분류로 나눌 수 있음
  * 의존성 주입(DI)
  * 의존성 룩업(DL)
    * 이들은 다시 구체적인 IoC 구현제로 나늼.

* IoC 종류
  * 의존성 주입(DI) : 이 방식의 IoC에서는 IoC 컨테이너가 컴포넌트에 의존성을 주입합니다.
    * 생성자(constructor) 의존성 주입
    * 수정자(setter) 의존성 주입
  * 의존성 룩업(DL) : 이 방식의 IoC에서는 컴포넌트 스스로 의존성의 참조를 가져와야 합니다.
     * 의존성 풀(Dependency Pull)
     * 의존성 룩업(CDL)
     
* 3.2.1 의존성 풀
  * 의존성 풀에서는 필요에 따라 레지스트리에서 의존성을 가져오게 됩니다.
    ex) JNDI API를 사용한 EJB 컴포넌트 룩업
        * JNDI(Java Naming and Directory Interface)는 
          * 디렉터리 서비스에서 제공하는 데이터 및 객체를 발견(discover)하고 참고(lookup)하기 위한 자바 API
          * 서버에서 관리하고 있는 리소스에 대한 정보를 알고 있고 특정 리소스를 찾아서 사용할 수있도록 객체를 반환
          
        ```java
         // 추억의 lookup 소스..

         public class DatabaseManager
         {
            public static Connection getConnection() throws Exception
            {
               Context ctx = new InitialContext();
               DataSource ds = (DataSource) ctx.lookup("java:comp/env/jdbc/myoracle");
               return ds.getConnection();
            }
         }
         ```

  * 스프링 프레임워크도 자신이 관리하는 컴포넌트를 가져오는 메커니증 중 하나로서 의존성 풀을 제공
  * 의존성 풀 사용 예
 
```java

package com.apress.prospring5.ch3;

import com.apress.prospring5.ch2.decoupled.MessageRenderer;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class DependencyPull {
    public static void main(String... args) {
        ApplicationContext ctx = new ClassPathXmlApplicationContext
           ("spring/app-context.xml");

        MessageRenderer mr = ctx.getBean("renderer", MessageRenderer.class);
        mr.render();
    }
}
```


* 3.2.2 문맥에 따른 의존성 룩업(CDL)
  * 의존성 풀처럼 특정 중앙 레지스트리에서 의존성을 가져오는 것이 아니라 **자원을 관리하는 컨테이너**에서 의존성을 가져옴
  * 늘 수행되는 것이 아니라 몇 사기 정해진 시점에 수행
  * 다음은 문맥에 따른 의존성 룩업 메커니즘
    * 의존 객체 -> 룩업 -> 컨테이너 
  *  컨테이너에서 의존성을 가져오는 컴포넌트
  
```java
public class ContextualizedDependencyLookup implements ManagedComponent {

    private Dependency dependency;

    // 1)의존성 룩업을 수행하는 메소드
    
    @Override
    public void performLookup(Container container) {
        this.dependency = (Dependency) container.getDependency("myDependency");
    }

    @Override
    public String toString() {
        return dependency.toString();
    }
}
```

3.2.3 생성자 의존성 주입
* 컴포넌트의 생성자(또는 여러 생성자)를 이용해서 해당 컴포넌트가 필요로하는 의존성을 제공하는 방식.
* 어떤 컴포넌트가 의존성을 인수로 가져오도록 생성자 또는 여러 생성자를 선언한다면 IoC 컨테이너는 해당 컴포넌트를 초기화할 때 컴포넌트에 필요한 의존성을 전달함.
* 주의점 : 생성자 주입을 사용할 때 의존성 주입 없이는 빈을 생성할 수 없으므로 **반드시 의존성을 주입**해야함!
* 생성자 의존성 주입 예제 코드

```java
public class ConstructorInjection {
	private Dependency dependency;

	public ConstructorInjection(Dependency dependency) {
		this.dependency = dependency;
	}

	@Override
	public String toString() {
		return dependency.toString();
	}
}
```

3.2.4 수정자 의존성 주입
 * 수정자(setter) 의존성 주입 방식에서 IoC 컨테이너는 자바빈 방식의 **수정자 메서드**를 이용해 컴포넌트의 의존성을 주입.
 * 컴포넌트의 수정자는 **IoC 컨테이너가 관리할 수 있도록 의존성을 노출**함.
 * 수정자 주입을 사용할 때 명확한 것은 의존성 없이도 객체를 생성할 수 있으며 해당 수정자를 호출해 의존성을 나중에 제공할 수 있음.
 * 의존성 주입이 필요한 일반적인 컴포넌트 예제

```java
public class SetterInjection {

	private Dependency dependency;

	public void setDependency(Dependency dependency) {
		this.dependency = dependency;
	}

	@Override
	public String toString() {
		return dependency.toString();
	}
}
```

3.2.5 **의존성 주입** vs. 의존성 룩업
* 현재 사용하는 컨테이너에 따라 IoC의 방식이 정해짐
* ex) EJB 2.1 이하 버전을 사용할 때 EJB를 JEE 컨테이너에서 가져오려면 의존성 룩업(JNDI를 통한) 방식의 IoC를 사용해야 함.
      스프링에서는 초기 빈 룩업을 제외하면 컴포넌트와 의존성은 항상 의존성 주입 방식의 IoC를 이용해 연결됨.
* 주입 방식을 선택하는 가장 큰 이유는 의존성 주입을 사용하면 그만큼 개발이 쉬워지기 때문. 작성해야 하는 코드량 줄이고 코드도 간결. IDE를 이용해 자동화도 가능.
* 주입 코드는 **객체가 필드에만 저장**됨. 저장소나 컨테이너에서 의존성을 가져오는 코드가 전혀 필요하지 않음. 따라서 코드는 훨씬 단순해지고 에러도 줄어듬.

3.2.6 수정자 주입 vs. 생성자 주입
* 생성자 주입
  * 컴포넌트 사용 전에 해당 컴포넌트의 의존성을 반드시 갖고 있어야 할 때 매우 유용. 의존성 점검 메커니즘을 제공하는지와 상관없이 의존성에 대한 요구사항 지정 가능.
  * 빈 객체를 불변 객체로 사용 가능.
* 수정자 주입
  * 기존 의존성을 제공할 때 일반적으로 **수정자 주입이 의존성 주입에 가장 좋은 방법**
  * 인터페이스에서 모든 의존성을 선언할 수 있음
  
* 의존성 주입 메소드를 비즈니스 인터페이스에서 정의하지 않고, 비즈니스 인터페이스를 구현하는 클래스에서 이 메소드를 정의!

```java
public interface Oracle {
    String defineMeaningOfLife();
}
```

```java
public class BookwormOracle implements Oracle {
    private Encyclopedia encyclopedia;

    public void setEncyclopedia(Encyclopedia encyclopedia) {
        this.encyclopedia = encyclopedia;
    }

    @Override
    public String defineMeaningOfLife() {
        return "Encyclopedias are a waste of money -  go see the world instead";
    }
}
```

* BookwormOracle 클래스는 Oracle 인터페이스를 구현했을 뿐만 아니라 의존성 주입을 위한 수정자도 정의
* 스프링은 이와 같은 구조를 다루는데 훨씬 더 편리
* 여기서 비즈니스 인터페이스에서 의존성을 정의할 필요없음
* 의존성을 정의하는 인터페이스를 사용할 수 있다는 것이 수정자 주입의 잘 알려진 장점!
  * 하지만 실제로는 주입을 위한 수정자가 사용자 인터페이스의 외부에 존재하도록 노력해야함
  
**3.3 스프링 제어 역전**
* 제어 역정(Inversion of Control, IoC)은 스프링이 하는 일 중에 가장 큰 부분을 차지!
* 의존성 룩업 기능이 제공되지만, **스프링 구현의 핵심은 의존성 주입**임!
  * 스프링의 의존성 주입 메커니증
    [의존 객체] <------의존성 주입------- [스프링 BeanFactory 컨테이너]

3.4 빈(Bean)과 빈 팩터리(Bean Factory)
스프링의 의존성 주입 컨테이너의 핵심은 **빈 백터리 인터페이스** 입니다.
* 빈 팩터리
  * 컴포넌트 관리
  * 컴포넌트의 라이프사이클뿐만 아니라 의존성까지 관리

3.4.2 BeanFactory 구현체
* 독립 실행형 자바 어플리케이션에서 원하는 처리를 하기 위해 스프링의 BeanFactory를 초기화하고 oracle 빈을 가져오는 방법 코드

```java
public class XmlConfigWithBeanFactory {

	public static void main(String... args) {
	        // BeanFactory 구현체 중 하나인 DefaultListableBeanFactory 사용
		DefaultListableBeanFactory factory = new DefaultListableBeanFactory();
		
		// XmlBeanDefinitionReader를 사용해 XML 파일의 BeanDefinition 정보 읽음
		XmlBeanDefinitionReader rdr = new XmlBeanDefinitionReader(factory);
		
		rdr.loadBeanDefinitions(new ClassPathResource("spring/xml-bean-factory-config.xml"));
		
		// oracle 빈을 가져오기
		Oracle oracle = (Oracle) factory.getBean("oracle");
		
		System.out.println(oracle.defineMeaningOfLife());
	}
}
```

* xml-bean-factory-config.xml

```xml
<?xml version="1.0" encoding="UTF-8"?>
    
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://www.springframework.org/schema/beans 
        http://www.springframework.org/schema/beans/spring-beans.xsd">

    <bean id="oracle" name="wiseworm" class="com.apress.prospring5.ch3.BookwormOracle"/>
</beans>
```

3.4.3 애플리케이션 컨텍스트(ApplicationContext)
* 스프링의 애플리케이션 컨텍스트 인터페이스는 **BeanFactory를 상속한 인터페이스**
* DI 서비스 외에도 트랜잭션 서비스, AOP 서비스, 국제화(il8n)를 위한 메시지 소스, 애플리케이션 이벤트 처리와 같은 여러 서비스 제공
* 스프링 기반 애플리케이션 개발 할 때 **ApplicationContext 인터페이스**를 이용해 스프링을 사용하는 것을 권장

* 스프링은 ApplicationContext를 
  * **직접 코드**로 **부트스트랩**(직접 인스턴스를 생성하고 적절한 애플리케이션 구성을 불러오는 방식)하거나
  * 웹 컨테이너 환경에서 **ContextLoaderListener를 이용**해 부트스트랩 합니다.
  

3.5.1 스프링 구성 옵션 설정하기
* 스프링에서 애플리케이션 구성을 정의할 수 있는 옵션
  * 빈 정의 : 프로퍼티 or XML 파일을 사용해 빈 정의할 수 있도록 지원
  * JDK 5가 출시되고, 스프링이 자바 애너테이션 지원하면서 스프링 2.5부터는 ApplicationContext를 구성하는데 자바 애너테이션을 지원하기 시작!
  * XML과 애너테이션 방식 중 어느것이 더 나을까 -> 각 장단점이 있기에 정답 없음.
    * XML 파일을 사용하면 모든 구성을 자바에서 분리해 외부에서 관리
    * 애너테이션을 사용하면 개발자가 코드 내에서 DI 구성을 정의하고 확인 가능
  * 일반적인 접근 중 하나는
    * XML 파일에 애플리케이션의 인프라(예를 들어 데이터 소스, 트랜잭션 관리자, JMS 연결 팩터리(Connection Factory), JMX 등) 정의하고
    * 애너테이션으로 DI 구성(주임 가능 빈과 빈의 의존성)을 정의하는 방식
  => 어떤 옵션을 선택하는지, 선택한 방법을 일관성 있게 준수하고 전체 개발팀이 분명히 이해할 수 있게 메시지를 명확히 전달
  
  
3.5.2 기본 구성의 개요
* XML 구성을 사용하려면 애플리케이션에서 필요한 **스프링 네임스페이스 베이스**를 선언해야함


* 스프링 빈 정의에 사용하는 네임스페이스 선언의 예 (app-context-xml.xml)

```xml
<?xml version="1.0" encoding="UTF-8"?>

<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:p="http://www.springframework.org/schema/p"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
          http://www.springframework.org/schema/beans/spring-beans.xsd">

    <bean id="renderer"
        class="com.apress.prospring5.ch2.decoupled.StandardOutMessageRenderer"
        p:messageProvider-ref="provider"/>

    <bean id="provider"
        class="com.apress.prospring5.ch2.decoupled.HelloWorldMessageProvider"/>
</beans>
```

* **컴포넌트 스캐닝 설정**을 한 XML 구성 파일 (app-context-annotation.xml)

```xml
<?xml version="1.0" encoding="UTF-8"?>

<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:context="http://www.springframework.org/schema/context"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
          http://www.springframework.org/schema/beans/spring-beans.xsd
          http://www.springframework.org/schema/context 
          http://www.springframework.org/schema/context/spring-context.xsd">

    <context:component-scan 
          base-package="com.apress.prospring5.ch3.annotated"/>
</beans>
```

* <context:component-scan> 태그는 
  * 지정한 패키지의 모든 하위 패키지에 있는 클래스에 선언된 @Autowired, @Inject, @Resource 애너테이션 뿐만 아니라
  * @Component, @Controller, @Repository, @Service 애너테이션이 선언된, 의존성 주입이 가능한 빈의 코드를 스캔하도록 스프링에게 지시함!!
  * 여러 패키지 정의 가능 : <context:component-scan> 태그에서 쉼표, 세미콜론, 공백을 구분 기호로 사용해 여러 패키지를 정의할 수 있음
  * 스캔 범위 제어 가능 : 이 태그에서는 컴포넌트 스캔의 범위와 제외 범위를 지정해 스캔 범위 제어 가능

  
  * 스캔에서 제외할 대상(클래스 또는 인터페이스) 예

```xml
<?xml version="1.0" encoding="UTF-8"?>

<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:context="http://www.springframework.org/schema/context"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
          http://www.springframework.org/schema/beans/spring-beans.xsd
          http://www.springframework.org/schema/context 
          http://www.springframework.org/schema/context/spring-context.xsd">

    <context:component-scan 
		base-package="com.apress.prospring5.ch3.annotated"/>
	  <context:exclude-filter type="assignable" expression="com.example.NotAService"/>
    </context:component-scan>

</beans>
```


3.5.3 스프링 컴포넌트 선언하기
* 스프링에게 이 빈(개발한 클래스)이 다른 빈에 주입될 수 있다는 것을 알려주고, 스프링이 이 빈들을 관리하게 해야 함.


