* IoC와 DI의 주 목적 : 컴포넌트의 의존성을 제공하고 이러한 의존성을 라이프사이클 전반에 걸쳐 관라하는 것보다 간편한 메커니즘을 제공하는 것.

* IoC 두 가지 하위분류로 나눌 수 있음
  * 의존성 주입(DI)
  * 의존성 룩업(DL)
    * 이들은 다시 구체적인 IoC 구현제로 나늼.

* IoC 종류
  * 의존성 주입(DI) : 이 방식의 IoC에서는 IoC 컨테이너가 컴포넌트에 의존성을 주입합니다.
    * 생성자(constructor) 의존성 주입
    * 수정자(setter) 의존성 주입
  * 의존성 룩업(DL) : 이 방식의 IoC에서는 컴포넌트 스스로 의존성의 참조를 가져와야 합니다.
     * 의존성 풀(Dependency Pull)
     * 의존성 룩업(CDL)
     
* 3.2.1 의존성 풀
  * 의존성 풀에서는 필요에 따라 레지스트리에서 의존성을 가져오게 됩니다.
    ex) JNDI API를 사용한 EJB 컴포넌트 룩업
        * JNDI(Java Naming and Directory Interface)는 
          * 디렉터리 서비스에서 제공하는 데이터 및 객체를 발견(discover)하고 참고(lookup)하기 위한 자바 API
          * 서버에서 관리하고 있는 리소스에 대한 정보를 알고 있고 특정 리소스를 찾아서 사용할 수있도록 객체를 반환
          
        ```java
         // 추억의 lookup 소스..

         public class DatabaseManager
         {
            public static Connection getConnection() throws Exception
            {
               Context ctx = new InitialContext();
               DataSource ds = (DataSource) ctx.lookup("java:comp/env/jdbc/myoracle");
               return ds.getConnection();
            }
         }
         ```

  * 스프링 프레임워크도 자신이 관리하는 컴포넌트를 가져오는 메커니증 중 하나로서 의존성 풀을 제공
  * 의존성 풀 사용 예
 
```java

package com.apress.prospring5.ch3;

import com.apress.prospring5.ch2.decoupled.MessageRenderer;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class DependencyPull {
    public static void main(String... args) {
        ApplicationContext ctx = new ClassPathXmlApplicationContext
           ("spring/app-context.xml");

        MessageRenderer mr = ctx.getBean("renderer", MessageRenderer.class);
        mr.render();
    }
}
```


* 3.2.2 문맥에 따른 의존성 룩업(CDL)
  * 의존성 풀처럼 특정 중앙 레지스트리에서 의존성을 가져오는 것이 아니라 **자원을 관리하는 컨테이너**에서 의존성을 가져옴
  * 늘 수행되는 것이 아니라 몇 사기 정해진 시점에 수행
  * 다음은 문맥에 따른 의존성 룩업 메커니즘
    * 의존 객체 -> 룩업 -> 컨테이너 
  *  컨테이너에서 의존성을 가져오는 컴포넌트
  
```java
public class ContextualizedDependencyLookup implements ManagedComponent {

    private Dependency dependency;

    @Override
    public void performLookup(Container container) {
        this.dependency = (Dependency) container.getDependency("myDependency");
    }

    @Override
    public String toString() {
        return dependency.toString();
    }
}
```

3.2.3 생성자 의존성 주입
* 컴포넌트의 생성자(또는 여러 생성자)를 이용해서 해당 컴포넌트가 필요로하는 의존성을 제공하는 방식.
* 어떤 컴포넌트가 의존성을 인수로 가져오도록 생성자 또는 여러 생성자를 선언한다면 IoC 컨테이너는 해당 컴포넌트를 초기화할 때 컴포넌트에 필요한 의존성을 전달함.
* 주의점 : 생성자 주입을 사용할 때 의존성 주입 없이는 빈을 생성할 수 없으므로 **반드시 의존성을 주입**해야함!
* 생성자 의존성 주입 예제 코드

```java
public class ConstructorInjection {
	private Dependency dependency;

	public ConstructorInjection(Dependency dependency) {
		this.dependency = dependency;
	}

	@Override
	public String toString() {
		return dependency.toString();
	}
}
```

3.2.4 수정자 의존성 주입
 * 수정자(setter) 의존성 주입 방식에서 IoC 컨테이너는 자바빈 방식의 수정자 메서드를 이용해 컴포넌트의 의존성을 주입.
 * 컴포넌트의 수정자는 **IoC 컨테이너가 관리할 수 있도록 의존성을 노출**함.
 * 의존성 주입이 필요한 일반적인 컴포넌트 예제

```java
public class SetterInjection {

	private Dependency dependency;

	public void setDependency(Dependency dependency) {
		this.dependency = dependency;
	}

	@Override
	public String toString() {
		return dependency.toString();
	}
}
```
 
